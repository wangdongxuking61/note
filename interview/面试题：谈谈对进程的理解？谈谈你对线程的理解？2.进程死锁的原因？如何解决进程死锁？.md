### 2谈谈对进程的理解？
答：首先进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位，进程有五方面的特点：第一：动态性:进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。第二： 并发性:任何进程都可以同其他进程一起并发执行第三：独立性:进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位;第四：异步性:由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进第五：结构特征:进程由程序、数据和进程控制块三部分组成。进程可以使用fork（）函数来创建子进程也可以使用vfork（）来实现进程，使用的时候注意不要产生僵尸进程和孤儿进程。
 
### 3.谈谈对线程的理解？
答：线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流，线程有四方面特点：第一，线程有独立的堆栈段，共享地址空间，开销较小，切换速度较快。第二，线程间的通信机制比较方便。第三，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。线程使CPU系统更加有效。第四,线程改善了程序结构，避免了一些嵌套循环。使用pthread_create()函数来创建线程，使用线程的时候有两点注意事项：第一，当多线程访问同一全局变量的时候，一定要加互斥量，也就是上锁。当然最后不要忘记了解锁。第二：正确处理线程结束的问题：因为一个线程的终止，线程的资源不会随线程的终止释放，我们需要调用pthread_join() 来获得另一个线程的终止状态并且释放该线程所占的资源。

### 2.进程死锁的原因？如何解决进程死锁？
答：首先呢进程有三态：执行状态，就绪状态，等待状态。。进程因等待资源的时候而睡眠进入等待状态，只有资源到来的时候才会唤醒进入就绪状态，进程死锁就会发生在这个阶段，如果多个进程同时占有对方需要的资源而同时请求对方的资源，而它们在得到请求之前不会释放所占有的资源，就会发生进程死锁，也就是进程不同步。
原因有两方面：1.系统能够提供的资源个数比要求该资源的进程少，即系统资源不足
2.进程推进顺序非法。
解决方案：因为进程死锁的发生有四个条件：
1.互斥条件：资源不能被共享，只能由一个进程使用。
2.请求与保持条件：已经得到资源的进程可以再次申请新的资源。
3.非剥夺条件：已经分配的资源不能从相应的进程中被强制地剥夺。
4.循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
所以我们可以从这几个方面着手去解决：
第一：根据互斥条件和请求和保持条件，我们可以采用资源静态分配策略，破坏"部分分配"条件；
第二：允许进程剥夺使用其他进程占有的资源，从而破坏"不可剥夺"条件；
第三：采用资源有序分配法，破坏"环路"条件。当然我们也不是必须严格遵循这几个必要条件去使用相对的侧列，我们也可以使用死锁检测方法，对资源的分配不加限制，即允许死锁的发生。但系统定时地运行一个"死锁检测"程序，判断系统是否已发生死锁，若检测到死锁发生则设法加以解除，可以使用资源剥夺法和撤销进程法来解除死锁。